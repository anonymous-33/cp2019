#!/usr/bin/env python

import os, sys, argparse
import numpy as np
import matplotlib.pyplot as plt
from pylab import poly1d, xlim, ylim
from more_itertools import locate

###
### main
###

def main():
    opts = get_options()

    if len(opts.files) <= 0:
        print ("usage: stats_plot [-n title] [-d plots_dir] [-t timeout] stats_file ...")
        quit(1)

    configs = []
    results = {}
    for file in opts.files:
        collect_stats(file, configs, results)

    good_data = check_integrity(configs, results)

    plot_table(configs, results)

    plots_dir = os.path.join(os.getcwd(), "plots")
    if not os.path.exists(plots_dir):
        os.makedirs(plots_dir)

    print ("Generating plots...")

    save_scatter_plots(plots_dir, configs, results, 1200.0)

    save_cactus_plots(plots_dir, configs, results, 1200.0)

    if not good_data:
        print ("missing data or inconsistent results, please fix the issue")
        quit(1)


###
### help functions
###

def get_options():
    """parses and returns input options"""
    parser = argparse.ArgumentParser(description="stats_plot")
    parser.add_argument("-n", type=str, help="plot name", default="default")
    parser.add_argument("-d", type=str, help="plots directory", default="plots")
    parser.add_argument("-t", type=int, help="timeout", default=1200)
    parser.add_argument("files", type=str, nargs=argparse.REMAINDER)
    return parser.parse_args()

def collect_stats(file, configs, results):
    """parses statistics summary file generated by run_experiment.sh, saving
    the interesting values in 'tools' and 'results'"""

    try:
        with open(file, 'r') as fd:
            file = os.path.realpath(file)
            config, ext = os.path.splitext(os.path.basename(file))
            if config not in configs:
                configs.append(config)

            for line in fd:
                idx, config_name, tool, status_m2f, time_m2f, search_type, \
                status_tool, time_tool, timeout, result_tool, opt_value, \
                mzn_file, dzn_file = ''.join(line.split()).split(":")[0:-1]

                mzn_name, mzn_ext = os.path.splitext(os.path.basename(mzn_file))
                dzn_name, dzn_ext = os.path.splitext(os.path.basename(dzn_file))

                if int(status_m2f) != 0:
                    print("error: mzn2fzn failed on `" + mzn_file + "` + `" + dzn_file + "` for `" + file + "`.")
                    quit(1)

                key = mzn_name + ":" + dzn_name

                if key not in results.keys():
                    results[key] = {}

                if (time_tool == "ERROR" or int(status_tool) == 137):
                    time_tool = timeout

                if (float(time_tool) <= 0.0):
                    time_tool = float(time_tool) + 0.001

                if int(status_tool) == 124:
                    time_tool = timeout

                results[key][config] = (float(time_tool), int(status_tool), search_type, \
                                        result_tool, opt_value)

    except Exception as e:
        print("error: file `" + file + "` does not exist or cannot be parsed, quitting.\n")
        print e
        quit(1)


def check_integrity(configs, results):
    """check that there are no obvious inconsistencies among solvers"""

    num_configs = len(configs)

    good = True

    for key in results.keys():
        num_results = len(results[key].keys())

        if (num_results < num_configs):
            print("warning: fewer results than expected for key `" + key + "`.")
            good = False
            pass

        v_results = []
        v_values = []

        for config in results[key].keys():
            data = results[key][config]

            if (data[1] != 0):
                # ignore entry, there is an error or timeout
                continue

            v_results.append(data[3])
            v_values.append(data[4])

        idxs = list(locate(v_results, lambda x: x != "ERROR"))
        if len(idxs) == 0:
            continue

        b_results = all(x == v_results[idxs[0]] for x in v_results)
        b_values = all(x == v_values[idxs[0]] for x in v_values)

        if not b_results or not b_values:
            print("error: inconsistent results for key `" + key + "`.")
            print("\tplease manually investigate the issue and change the tool")
            print("\texit status from 0 to 2 for the incorrect configuration / file")
            print results[key]
            good = False

    return good

def plot_table(configs, results):
    data = get_data_for_table(configs, results)

    print "%40s\t%10s\t%10s\t%10s\t%10s\t%10s\t%10s\t%10s\t%16s" % ("Config:", "Benchs:", "Solved:", "Incorrect:", "Timeouts:", "Unsupported:", "Unknown:", "Errors:", "Time (s.):")

    for config in configs:
        values = (config, data[config]["benchs"], data[config]["solved"], data[config]["incorrect"], data[config]["timeouts"], data[config]["unsupported"], data[config]["unknown"], data[config]["errors"], data[config]["cum_time"])
        print "%40s\t%10s\t%10s\t%10s\t%10s\t%10s\t%10s\t%10s\t%16s" % tuple(values)

def get_data_for_table(configs, results):

    ret = {}

    for config in configs:
        ret[config] = {
            "benchs"      : 0,
            "solved"      : 0,
            "timeouts"    : 0,
            "unsupported" : 0,
            "errors"      : 0,
            "unknown"     : 0,
            "cum_time"    : 0,
            "incorrect"   : 0
        }

    for key in results.keys():
        for config in results[key].keys():
            ret[config]["benchs"] = ret[config]["benchs"] + 1
            
            es = results[key][config][1]

            has_error = False

            unsupported_list = [-101, 155, -102, 154, -103, 153, -111, 145, -112, 144, -113, 143, -121, 134, -122, 134, -123, 133, -124, 132, -131, 125, -151, 105]
            # generic error: -151, 105
            # exception: -152, 104
            # sigsev: -139
            # non-linear: -101, 155
            # non-parseable: -103, 153
            # killed: -119, 137 (for memory or timing reasons)

            if (es == 124):
                ret[config]["timeouts"] = ret[config]["timeouts"] + 1
            elif es in unsupported_list:
                ret[config]["unsupported"] = ret[config]["unsupported"] + 1
                #print("warning: unsupported problem for `" + key + "`, " + config + ": " + str(es))
            elif es == 137:
                # killed for known reasons
                if 1190 <= results[key][config][0]:
                    ret[config]["timeouts"] = ret[config]["timeouts"] + 1
                else:
                    #print("warning: insufficient memory for `" + key + "`, " + config + " (" + str(results[key][config][0]) + "):")
                    ret[config]["errors"] = ret[config]["errors"] + 1
            elif es == 1:
                # incorrect result
                ret[config]["incorrect"] = ret[config]["incorrect"] + 1
            elif es != 0:
                ret[config]["errors"] = ret[config]["errors"] + 1
                #print("warning: error result for `" + key + "`, " + config + ":")
                #print results[key][config]
            elif results[key][config][3] == "UNKNOWN":
                ret[config]["unknown"] = ret[config]["unknown"] + 1
                #print("warning: unknown result for `" + key + "`, " + config + ":")
                print results[key][config]
            else:
                ret[config]["cum_time"] = ret[config]["cum_time"] + results[key][config][0]
                ret[config]["solved"] = ret[config]["solved"] + 1

    for config in configs:
        sum = ret[config]["solved"] + ret[config]["timeouts"] +    \
              ret[config]["unsupported"] + ret[config]["errors"] + \
              ret[config]["unknown"] + ret[config]["incorrect"]
        if ret[config]["benchs"] != sum:
            print("error: incorrect value in columns")
            print ret[config]
            quit(1)

    return ret

def get_xyz(x_tool, y_tool, results, timeout):
    x = []
    y = []
    z = []

    for bench in results.keys():
        x_data = results[bench][x_tool]
        y_data = results[bench][y_tool]

        error = False

        if x_data[1] != 0 and x_data[1] != 124 and x_data[1] != 137:
            x.append(timeout)
            error = True
        else:
            x.append(x_data[0])


        if y_data[1] != 0 and y_data[1] != 124 and x_data[1] != 137:
            y.append(timeout)
            error = True
        else:
            y.append(y_data[0])

        if error:
            z.append(0.5)
        else:
            if x_data[1] == 124 or y_data[1] == 124 or \
               x_data[1] == 137 or y_data[1] == 137 or \
                x_data[0] >= (timeout - 10) or y_data[0] >= (timeout - 10):
                z.append(1.0)
            else:
                z.append(0.0)

    return x, y, z

def save_scatter_plots(plots_dir, configs, results, timeout):
    for x_tool in configs:
        for y_tool in configs:

            if ("our_omt_tool_std-bin-bv-obvbs" not in y_tool and
                "our_omt_tool_std-bin-int" not in y_tool):
                continue

            if x_tool != y_tool:
                x, y, z = get_xyz(x_tool, y_tool, results, timeout)
                # args
                title   = "%s_%s"   % (x_tool, y_tool)
                x_label = "%s (s.)" % get_pretty_label(x_tool)
                y_label = "%s (s.)" % get_pretty_label(y_tool)
                z_label = ""
                file_name = "%s/%s.png" % (plots_dir, title)
                plot_scatter_plot(title, x_label, y_label, z_label, x, y, z, timeout, file_name)

                file_name = "%s/%s.pdf" % (plots_dir, title)
                plot_scatter_plot(title, x_label, y_label, z_label, x, y, z, timeout, file_name)

def plot_scatter_plot(title, x_label, y_label, z_label, x, y, z, timeout, file_name):
    axis_font = {'fontname' : 'Arial', 'size':'16', 'weight':'bold'}
    colors    = ('b', 'g', 'r', 'c', 'm', 'y', 'k', 'w')

    fig = plt.figure()
    ax = fig.add_subplot(1, 1, 1)

    ax.tick_params(axis='both', which='minor', labelsize=14)
    ax.tick_params(axis='both', which='major', labelsize=14)

    ax.axvline(x=timeout, color='r', zorder=3, linestyle='--')
    ax.axhline(y=timeout, color='r', zorder=3, linestyle='--')
    c = np.arange(0, timeout, 0.1)
    ax.plot(c, c, c='r', zorder=3, linestyle='--')

    scat = ax.scatter(x, y, c=z, cmap=plt.cm.brg, marker='x', linewidth=1, s=150, zorder=2)
    #fig.colorbar(scat, orientation='vertical', label=z_label) # unbounded density bar

    ax.grid(True)
    xlim([0.1, timeout*1.2])
    ylim([0.1, timeout*1.2])

#    ax.set_title(title, **axis_font)
    ax.set_ylabel(y_label, **axis_font)
    ax.set_yscale('log')#, nonposy='clip')
    ax.set_xlabel(x_label, **axis_font)
    ax.set_xscale('log')#, nonposy='clip')
    ax.set_aspect('equal')  # does not truly work! 

    # dump to file
    plt.tight_layout()
    plt.savefig(file_name, bbox_inches='tight')
#   plt.show()
    plt.close(fig)

def get_cactus_data(configs, results, timeout):
    data = []

    for config in configs:
        v = []
        solved = 0
        for bench in results.keys():
            res = results[bench][config]
            if res[1] == 0 and res[0] < timeout:
                v.append(res[0])
                solved += 1
        v.sort()
        v = np.cumsum(v)

        config_data = {}
        config_data["config"] = config
        config_data["cum_times"] = v
        config_data["max"] = max(v)
        config_data["solved"] = solved
        data.append(config_data)

    v1 = {}
    v1v = []
    solved1 = 0
    v2 = {}
    v2v = []
    solved2 = 0

    for bench in results.keys():
        best_time1 = None
        best_config1 = None
        best_time2 = None
        best_config2 = None
        for config in configs:
            res = results[bench][config]
            if "our_omt_tool" in config:
                if res[1] == 0 and float(res[0]) < float(timeout):
                    if best_time1 is None:
                        best_time1 = res[0]
                        best_config1 = config
                    elif float(res[0]) < float(best_time1):
                        best_time1 = res[0]
                        best_config1 = config
            else:
                if res[1] == 0 and float(res[0]) < float(timeout):
                    if best_time2 is None:
                        best_time2 = res[0]
                        best_config2 = config
                    elif float(res[0]) < float(best_time2):
                        best_time2 = res[0]
                        best_config2 = config

        if best_time1 is not None:
            v1[bench] = (best_config1, best_time1)
            v1v.append(best_time1)
            solved1 += 1
        else:
            v1[bench] = ("none", 2400)
#        else:
#            v1.append(600.0)
#            solved1 += 0

        if best_time2 is not None:
            v2[bench] = (best_config2, best_time2)
            solved2 += 1
            v2v.append(best_time2)
        else:
            v2[bench] = ("none", 2400)
#        else:
#            v2.append(600.0)
#            solved2 += 0

    v = []
    k = {}
    solved = 0

    for bench in results.keys():
        best_time = None
        best_config = None
        for config in configs:
            res = results[bench][config]
            if res[1] == 0 and float(res[0]) < float(timeout):
                if best_time is None:
                    best_time = res[0]
                    best_config = config
                elif float(res[0]) < float(best_time):
                    best_time = res[0]
                    best_config = config

        if best_time is not None:
            k[bench] = (config, best_time)
            v.append(best_time)
            solved += 1
        else:
            k[bench] = ("none", 2400)
#        else:
#            v.append(600.0)
#            solved += 0

    v.sort()
    v = np.cumsum(v)

    config_data = {}
    config_data["config"] = "virtual best"
    config_data["cum_times"] = v
    config_data["max"] = max(v)
    config_data["solved"] = solved
    data.append(config_data)

    v1v.sort()
    v1v = np.cumsum(v1v)
    config_data1 = {}
    config_data1["config"] = "vbest_opti"
    config_data1["cum_times"] = v1v
    config_data1["max"] = max(v1v)
    config_data1["solved"] = solved1
    data.append(config_data1)

    v2v.sort()
    v2v = np.cumsum(v2v)
    config_data2 = {}
    config_data2["config"] = "vbest_fdcp"
    config_data2["cum_times"] = v2v
    config_data2["max"] = max(v2v)
    config_data2["solved"] = solved2
    data.append(config_data2)

    #print(config_data)
    #print(config_data1)
    #print(config_data2)

    bop = {}
    bfd = {}
    eq  = {}
    for bench in results.keys():
        oel = v1[bench]
        fel = v2[bench]
        kel = k[bench]
        if oel[1] < fel[1]:
            bop[bench] = (oel[0], oel[1], fel[0], fel[1])
        elif fel[1] < oel[1]:
            bfd[bench] = (oel[0], oel[1], fel[0], fel[1])
        else:
            eq[bench] = (oel[0], oel[1], fel[0], fel[1])
    #print("\nBETTER OUR_OMT_TOOL:")
    #print(bop)
    #print("\nBETTER FDCP:")
    #print(bfd)
    #print("\nEQUAL:")
    #print(eq)

    for config in configs:
        bta = 0
        bto = 0
        btf = 0
        for bench in results.keys():
            res = results[bench][config]
            if res[1] == 0 and float(res[0]) <= float(v1[bench][1]):
                bto = bto + 1
            if res[1] == 0 and float(res[0]) <= float(v2[bench][1]):
                btf = btf + 1
            if res[1] == 0 and float(res[0]) <= float(v1[bench][1]) and float(res[0]) <= float(v2[bench][1]):
                bta = bta + 1
        print(config)
        print("Better than all: " + str(bta))
        print("Better than FDCP: " + str(btf))
        print("Better than Opti: " + str(bto))

    data.sort(key = lambda x : x["max"])
    data.sort(key = lambda x : x["solved"], reverse=True)
    return data

def save_cactus_plots(plots_dir, configs, results, timeout):
        title     = "Tools Performance"
        x_label = "No. solved"
        y_label = "Cum. time (s.)"
        file_name = "%s/cactus_plot.pdf" % plots_dir
        data      = get_cactus_data(configs, results, timeout)
        
        configs += "virtual best"
        configs += "vbest_opti"
        configs += "vbest_fdcp"

        file_name = "%s/cactus_plot.png" % plots_dir
        plot_cactus_plot(title, x_label, y_label, data, timeout, file_name)

        file_name = "%s/cactus_plot.pdf" % plots_dir
        plot_cactus_plot(title, x_label, y_label, data, timeout, file_name)

def plot_cactus_plot(title, x_label, y_label, data, timeout, file_name):
    axis_font  = {'fontname' : 'Arial', 'size' : '14', 'weight': 'bold'}
    std_colors = ('b', 'g', 'r', 'c', 'm', 'y', 'k', 'w')
    num_keys   = len(data)
    cmap       = plt.get_cmap('Dark2_r')
    cmap       = plt.cm.nipy_spectral
    colors     = [cmap(i) for i in np.linspace(0, 1, num_keys)]
    styles     = ('--', '-.', '-', ':')

    fig = plt.figure()
    ax = fig.add_subplot(1, 1, 1)

    idx = 0
    max_y = 0
    for config_data in data:
        y = config_data["cum_times"]
        x = np.arange(1, len(y) + 1)
        ax.plot(x, y, styles[idx % len(styles)], label=get_pretty_label(config_data["config"]), marker=None, color=colors[idx], linewidth=1)
        idx += 1
        if config_data["max"] > max_y:
            max_y = config_data["max"]

    ax.grid(True)
#    ax.set_title(title, **axis_font)
    ax.set_ylabel(y_label, **axis_font)
    ax.set_xlabel(x_label, **axis_font)
    ax.set_yscale('log', nonposy='clip')
    plt.ylim([0, max_y * 1.5])

    lgd = plt.legend(loc=5, ncol=2, bbox_to_anchor=(0.999, 0.195), prop={'size' : 7})

    plt.savefig(file_name, bbox_extra_artists=(lgd,), bbox_inches='tight')#, bbox_inches=0)
    plt.close(fig)

def mkdir_p(path):
    """make a directory and any missing ancestor if needed"""
    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise


def get_pretty_label(name):
    res = ""
    if "our_omt_tool" in name:
        res += "Our-OMT-Tool("
        if "bv" in name:
            res += "fzn+bv"
        elif "int" in name:
            res += "fzn+int"
        res += ")"
    elif "ortools_cp" in name:
        res = "OR-Tools(cp)"
    elif "ortools_sat" in name:
        res = "OR-Tools(sat)"
    elif "choco" in name:
        res = "Choco()"
    elif "chuffed" in name:
        res = "Chuffed()"
    elif "flatzinc" in name:
        res = "G12(fd)"
    elif "gurobi" in name:
        res = "Gurobi()"
    elif "hcsp" in name:
        res = "HaifaCSP()"
    elif "izplus" in name:
        res = "iZplus()"
    elif "jacop" in name:
        res = "JaCoP()"
    elif "picat_cp" in name:
        res = "Picat(cp)"
    elif "picat_sat" in name:
        res = "Picat(sat)"
    elif "gecode" in name:
        res = "Gecode()"
    elif "virtual" in name:
        res = "virtual best(all)"
    elif "vbest_opti" in name:
        res = "virtual best(Our-OMT-Tool)"
    elif "vbest_fdcp" in name:
        res = "virtual best(MiniZinc)"
    else:
        res = name
    return res

###
###
###

if (__name__ == "__main__"):
    main()
